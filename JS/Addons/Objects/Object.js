/* 
В JS есть 8 типов данных
1) Число
«специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.
*/
let n = 123;
n = 12.345;
alert(Infinity); // Infinity
alert("не число" / 2); // NaN, такое деление является ошибкой
/* 
2) BigInt символ "n" в конце означает, что это BigInt */
const bigInt = 1234567890123456789012345678901234567890n;
/* 
3) Строка
*/
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;

/* 
4) bool
*/
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

/* 
5) null (Отдельный тип)
*/
let age = null;
/* 
6) «undefined» Оно означает, что «значение не было присвоено».
*/
let age2 = 123;

// изменяем значение на undefined
age2 = undefined;

alert(age); // "undefined"

/* 
7) symbol
*/

/* 
8) Object
*/ Создание
let user = new Object(); // синтаксис "конструктор объекта"

let user = {};  // синтаксис "литерал объекта

/* 
При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:
*/
let user = {     // объект
    name: "John",  // под ключом "name" хранится значение "John"
    age: 30        // под ключом "age" хранится значение 30
};
// получаем свойства объекта:
alert(user.name); // John
alert(user.age); // 30

// Удаление свойства
delete user.age;
const user2 = {
    name: "John"
};

user2.name = "Pete"; // Не выдаст ошибку - константа не даёт поменять только переменную, содержимое менять позволительно.

alert(user.name); // Pete


let user = {
    name: "John",
    age: 30,
    "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};
user["likes birds"] = true; // Обращение свойств которые были объявленны через "name" происходит через class["name"]

//Вычисляемые свойства
let prop = "abc"

let myClass = {
    [prop]: 5
}
console.log(myClass[prop]);

// эти имена свойств допустимы
let obj = {
    for: 1,
    let: 2,
    return: 3
};

//Все ключи свойств превращаются в string
let obj = {
    0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert(obj["0"]); // Тест
alert(obj[0]); // Тест (то же свойство)

// свойство __proto__ является исключением
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали

/* 
Также существует специальный оператор "in" для проверки существования свойства в объекте.

Синтаксис оператора:
*/
let user = { name: "John", age: 30 };

alert("age" in user); // true, user.age существует
alert("blabla" in user); // false, user.blabla не существует

//Цикл "for..in"
for (key in object) {
    // тело цикла выполняется для каждого свойства объекта
}
//Упорядочение свойств объекта
let codes = {
    "49": "Германия",
    "41": "Швейцария",
    "44": "Великобритания",
    // ..,
    "1": "США"
};

for (let code in codes) {
    alert(code); // 1, 41, 44, 49
}
let user = {
    name: "John",
    surname: "Smith"
};
user.age = 25; // добавим ещё одно свойство

// не целочисленные свойства перечислены в порядке создания
for (let prop in user) {
    alert(prop); // name, surname, age
}
/* 
Целочисленные свойства (св-ва ключи которых могут быть переведенны в числа) будут располагаться в порядке возрастания 1-...n
У строковых свойств будет сортироваться от времени добавления
*/