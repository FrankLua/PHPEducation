<?php
/* 
Заместитель (англ. Proxy) — структурный шаблон проектирования, предоставляющий объект, который контролирует доступ к другому объекту,
перехватывая все вызовы (выполняет функцию контейнера).
Заместитель позволяет создать промежуточный слой между бизнес-логикой приложения и деталями.
 Пример:
 В существующий класс реализованный как деталь (плагин) для основной бизнес-логики
требуется добавить некую дополнительную функциональность:
*  1) Кеширование
*  2) Проверка доступа перед исполнением
*  3) Шифрование запроса перед отправкой (расшифровка ответа)
*  4) Логирование
*  5) Анализ кол-ва обращений и тп




Постановка задачи. Имеется действующий отлаженный проект на PHP, содержащий десяток моделей,
в каждой из которых по 5 методов выборок данных.
Проект растет, всё хорошо, но в определенный момент, под тяжестью нагрузки, назревает необходимость
добавить каким-то образом кэширование обращений к моделям


Первый способ «в лоб»: в каждый метод модели добавляем кэширование по стандартной схеме:
проверить кэш, если есть актуальные данные, возвращаем их, если нет — выполняем метод,
как было до этого и плюс в конце еще пишем, полученные из базы, данные в кэш. Сказать,
что это ужасный способ значит, ничего не сказать, поэтому просто скажу, почему это плохо:

Нарушается один из принципов SOLID, «код должен быть открыт для расширения, но закрыт для изменений»,
т.е. мы берем и ломаем уже отлаженный выпущенный в продакшн код для того, чтобы добавить новую функциональность,
 а это всегда вызывает шквал ошибок и как следствие недовольство пользователей и заказчика.


В одном и том же коде смешивается логика получения данных и кэширование, что приводит к распуханию классов и беспощадному повторению кода.

Сделав так, мы лишаемся возможности получить живые данные в обход кэша (следующим шагом будет добавление флага $nocache).

Очень высокая трудоёмкость впиливания кэширования таким способом и ещё большая трудоёмкость выпиливания его потом.

public async Task<Day> GetObjectBy(string idOrEmail)
        {
            try
            {
                var day = _cache.GetObject(idOrEmail) as Day;
                if (day == null)
                {
                    day = await _days.FindAsync(day => day._id == idOrEmail)
                    .Result
                    .FirstAsync();
                    _cache.SetObject(idOrEmail, day, 10);
                    return day;
                }
                return day;


            }
            catch (Exception ex)
            {
                if (ex.Message == DbExMessage.NoElements)
                {
                    throw new HttpRequestException("404 Not Found", null, HttpStatusCode.NotFound);
                }
                throw new HttpRequestException("500 Shit happens", null, HttpStatusCode.NotFound);
            }
        }


Второй способ, «расширяем классы моделей»: добавляем в модели методы-дублеры,
которые оборачивают вызовы существующих методов в кэширование, например findById_Cached().

Вроде бы лучше, существующие методы не трогаем, вместо этого добавляем новые. Но остальные минусы на месте:
Смешивание логики.

Размеры классов растут ещё больше, чем в предыдущем способе.

Очень высокая трудоемкость (добавить 50 новых методов, в нашем примере) + заменить везде в приложении вызовы старых методов,
на новые, а если в будущем придется кэширование выпиливать, то еще и повторить все действия назад.

Третий способ «кэширующий прокси»,
*/



/**
 * Интерфейс Субъекта объявляет общие операции как для Реального Субъекта, так и
 * для Заместителя. Пока клиент работает с Реальным Субъектом, используя этот
 * интерфейс, вы сможете передать ему заместителя вместо реального субъекта.
 */
interface Subject
{
    public function request(): void;
}

/**
 * Реальный Субъект содержит некоторую базовую бизнес-логику. Как правило,
 * Реальные Субъекты способны выполнять некоторую полезную работу, которая к
 * тому же может быть очень медленной или точной – например, коррекция входных
 * данных. Заместитель может решить эти задачи без каких-либо изменений в коде
 * Реального Субъекта.
 */
class RealSubject implements Subject
{
    public function request(): void
    {
        echo "RealSubject: Handling request.\n";
    }
}

/**
 * Интерфейс Заместителя идентичен интерфейсу Реального Субъекта.
 */
class Proxy implements Subject
{
    /**
     * @var RealSubject
     */
    private $realSubject;

    /**
     * Заместитель хранит ссылку на объект класса РеальныйСубъект. Клиент может
     * либо лениво загрузить его, либо передать Заместителю.
     */
    public function __construct(RealSubject $realSubject)
    {
        $this->realSubject = $realSubject;
    }

    /**
     * Наиболее распространёнными областями применения паттерна Заместитель
     * являются ленивая загрузка, кэширование, контроль доступа, ведение журнала
     * и т.д. Заместитель может выполнить одну из этих задач, а затем, в
     * зависимости от результата, передать выполнение одноимённому методу в
     * связанном объекте класса Реального Субъект.
     */
    public function request(): void
    {
        if ($this->checkAccess()) {
            $this->realSubject->request();
            $this->logAccess();
        }
    }

    private function checkAccess(): bool
    {
        // Некоторые реальные проверки должны проходить здесь.
        echo "Proxy: Checking access prior to firing a real request.\n";

        return true;
    }

    private function logAccess(): void
    {
        echo "Proxy: Logging the time of request.\n";
    }
}

/**
 * Клиентский код должен работать со всеми объектами (как с реальными, так и
 * заместителями) через интерфейс Субъекта, чтобы поддерживать как реальные
 * субъекты, так и заместителей. В реальной жизни, однако, клиенты в основном
 * работают с реальными субъектами напрямую. В этом случае, для более простой
 * реализации паттерна, можно расширить заместителя из класса реального
 * субъекта.
 */
function clientCode(Subject $subject)
{
    // ...

    $subject->request();

    // ...
}

echo "Client: Executing the client code with a real subject:\n";
$realSubject = new RealSubject();
clientCode($realSubject);

echo "\n";

echo "Client: Executing the same client code with a proxy:\n";
$proxy = new Proxy($realSubject);
clientCode($proxy);