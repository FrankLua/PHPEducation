Интерфейсы в [[РНР]] объектов позволяют создавать код, который указывает, какие методы должен реализовать класс, без необходимости определять, как именно они должны быть реализованы. Интерфейсы разделяют пространство имён с классами и трейтами, поэтому они не могут называться одинаково.
На практике интерфейсы используются в двух взаимодополняющих случаях:

- Чтобы позволить разработчикам создавать объекты разных классов, которые могут использоваться взаимозаменяемо, поскольку они реализуют один и тот же интерфейс или интерфейсы. Типичный пример - несколько служб доступа к базе данных, несколько платёжных шлюзов или разных стратегий кеширования. Различные реализации могут быть заменены без каких-либо изменений в коде, который их использует.
- Чтобы разрешить функции или методу принимать и оперировать параметром, который соответствует интерфейсу, не заботясь о том, что ещё может делать объект или как он реализован. Эти интерфейсы часто называют `Iterable`, `Cacheable`, `Renderable` и так далее, чтобы описать их поведение.

Интерфейсы могут определять [магические методы](https://www.php.net/manual/ru/language.oop5.magic.php)

Класс может реализовать больше одного интерфейса! 

**Пример #1 Пример интерфейса**

```php
<?php  
  
// Объявим интерфейс 'Template'  
interface Template  
{  
public function setVariable($name, $var);  
public function getHtml($template);  
}  
  
// Реализация интерфейса  
// Это будет работать  
class WorkingTemplate implements Template  
{  
private $vars = [];  
  
public function setVariable($name, $var)  
{  
$this->vars[$name] = $var;  
}  
  
public function getHtml($template)  
{  
foreach($this->vars as $name => $value) {  
$template = str_replace('{' . $name . '}', $value, $template);  
}  
  
return $template;  
}  
}
```